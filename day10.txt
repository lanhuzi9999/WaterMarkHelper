桌面小部件的创建步骤
 1、创建桌面部件的布局
 2、创建元数据，描述桌面部件特性
 3、创建AppWidgetProvider的子类
 4、重写相关方法
    onEnabled
    onUpdate
    onDeleted
    onDisabled
 5、注册
  <receiver android:name="类名">
   <intent-filter>
    <action android:name="android.appwidget.action.APPWIDGET_UPDATE"/>
   </intent-filter>
   <meta-data
     android:name="android.appwidget.provider"
     android:resources="元数据资源"/>
  </receiver>
更新桌面部件的方法
 调用AppWidgetManager对象的updateAppWidget方法更新
为桌面小部件添加关联Activity
 1、创建关联Activity
    在Activity创建时 获取appWidgetId
    在Activity结束前设置返回值 将appWidgetId返回给桌面程序
 2、注册Activity
    <activity android:name="类名">
     <intent-filter>
       <action android:name="android.appwidget.action.APPWIDGET_CONFIGURE"/>
     </intent-filter>
    </activity>
 3、在元数据中添加android:configure属性确定关联Activity

AppWidgetProvider
 1、是BroadcastReceiver的子类
 2、基本工作原理是在其收到相关的广播时会调用几个主要方法
 3、主要方法:
  onEnabled:在向桌面添加部件类的第一个实例时执行
  onUpdate :在想桌面添加小部件的新实例，以及到达设定的定时更新时间时执行
  onDeleted:在从桌面移除小部件的实例时执行
  onDisabled:从桌面移除小部件的最后一个实例时执行
AppWidgetManager
 实例化:static AppWidgetManager getInstance(Context context)
 主要方法:
  void udpateAppWidget(ComponentName provider,RemoteViews views)
  void updateAppWidget(int appWidgetId,RemoteViews views)
  void updateAppWidget(int[] appWidgetIds,RemoteViews views)
 主要常量:
  ACTION_APPWIDGET_UDPATE
  ACTION_APPWIDGET_CONFIGURE
  ...
  EXTRA_APPWIDGET_ID

RemoteViews
 构造方法: RemoteViews(String pkgName,int layoutRes)
 主要方法:
  void setTextViewText(int textViewIdRes,CharSequence text)
  void setOnClickPendingIntent(int idRes,PendingIntent intent)
--------------------------------------------------------------
驻留广播
 发送：
   context.sendStickyBroadcast(intent)
 撤销
   context.removeStickyBroadcast(intent)  
 声明使用权限:android.permission.BROADCAST_STICKY
---------------------------------------------------------------
Android中的线程通信机制
 MessageQueue
 Looper
 Handler
  1、Handler在创建时必须关联到一个线程
     如果未明确指定所关联的线程，默认关联到
     其创建时所在线程，如果该线程中未创建消息队列
     则handler创建失败
  2、Handler只会向其关联的线程中的消息队列发送消息
  3、Handler中的消息处理逻辑
     消息在被处理时 总是传递给handler的dispatchMessage方法
     在该方法中：
      1）首先判断消息中是否包含Runnable对象,
      如果有，则在handler的关联线程中执行Runnable对象的run方法
      2）如果消息中不包含Runnable对象，则判断handler中是否包含callback
      如果有，则调用callback对象的handleMessage方法.
       如果callback的handleMessage方法返回true，则消息处理结束
       否则继续调用handler的handleMessage方法处理消息
      3）如果消息中不包含Runnnable对象且handler中不包含callback对象
      则执行handler的handleMessage方法处理消息
 主要属性
   private Looper looper      确定了handler对象关联的线程
   private Callback callback  消息处理的回调对象
 构造方法:
   Handler()
   Handler(Looper looper)
   Handler(Callback callback)
   Handler(Looper looper,Callback callback)
 主要方法:
   Looper getLooper()
   void dispatchMessage(Message msg)
   void handleMessage(Message msg)
   boolean sendEmptyMessage(int what)
   boolean sendemptyMessageAtTime(int what,long time)
   boolean sendEmptyMessageDelayed(int what,long delayedTime)
   boolean sendMessage(Message msg)
   boolean sendMessageAtTime(Message msg,long time)
   boolean sendMessageDelayed(Message msg,long delayedTime)
   boolean sendMessageAtFrontOfQueue(Message msg)
   boolean post(Runnable callback)
   bollean postAtFrontOfQueue(Runnable callback)
   boolean postAtDelayed(Runnable callback,long delayedTime)
   boolean postAttime(Runnable callback,time)
 Message
  主要的私有属性:
   private handler target
   private Runnable callback
  主要的公共属性
   int what
   int arg1
   int arg2
   Object obj
  构造方法：Message()
  静态方法:
   static Message obtain()
   static Message obtain(Handler target)
   static Message obtain(Handler target,Runnable callback)
   static Message obtain(Handler target,int what)
   static Message obtain(Handler target,int what,int arg1,int arg2)
   static Message obtain(Handler target,int what,Object obj)
   staitc Message obtain(Handler target,int what,int arg1,int arg1,Object obj)
   static Message obtain(Message msg)
  主要方法:
   void setData(Bundle data)
   Bundle getData()
   void sendToTarget()
   void setTarget(Handler target)
   Handler getTarget()
   Runnable getCallback()

Looper
 当looper从消息队列中取出一个消息之后
  msg.getTarget().dispatchMessage(msg);
  
Handler
 public void dispatchMessage(Message msg){
  if(msg.getCallback()!=null){
   msg.getCallback().run();
  }else if(this.callback!=null){
   if(!callback.handleMessage(msg)){
     this.handleMessage(msg);
   }
  }else{
   this.handleMessage(msg)
  }
 }

Application
 1、是Context的子类
 2、当应用程序启动时（进程创建时）创建Application实例
    当进程销毁时 销毁Application实例
 3、Application的实例在应用程序运行期间 有且仅有一个实例
 4、在可能的情况下 进行context传递时 尽可能的使用Application对象
 5、自定义Application
  1）创建Application的子类
  2）在AndroidManifest.xml中的application中使用android:name
     属性指定自定义的Application类型 
 6、获取Application对象的引用
  在Activity和Service中，直接调用 getApplication()
  在非Activity和Service的上下文环境中，调用(Application)getApplicationContext() 

调试
 1、使用Log日志
 2、断点调试
-----------------------------------------------------------------
媒体提供程序――图片
 images     ：_id  _data _display_name _size title width height 
 thumbnails ：_id  _data kind width  height
相关API
 MediaStore
  Images
   Media
    EXTERNAL_CONTENT_URI
    INTERNAL_CONTENT_URI 
    _ID DATA SIZE DISPLAY_NAME  TITLE...
    static Bitmap getBitmap(ContentResolver cr,Uri uri)
   Thumbnails
    EXTERNAL_CONTENT_URI
    INTERNAL_CONTENT_URI 
    _ID  DATA  KIND  WIDTH  HEIGHT
    MINI_KIND
    MICRO_KIND
    static Bitmap getThumbnail(ContentResolver cr,int imgId,int kind,Options opts)

class 计算机{
 CPU cpu;
 ...
 ArrayList<存储器> s;
}
----------------------------------------------
interface 存储器{
 byte[] read();
 void write(byte[] data);
}

class 某存储设备{
 public byte[] input(){}
 public void output(byte[] data){}
}

class 适配器 implements 存储器{
 private 某存储设备 store;
 public byte[] read(){
   return store.input();
 }
 public void write(byte[] data){
   store.output(data);
 }
}
适配器模式的三个角色
 1、源对象
 2、目标接口
 3、适配器:实现目标接口  包含源对象
----------------------------------------------
AdapterView
 1、是一个容器
 2、禁用了addView方法
 3、提供了setAdapter(Adapter adapter)方法，
    允许设置Adapter接口对象为其
    提供数据与item界面
 其主要子类：
  ListView
  Gallery
  GridView

  Spinner
Adapter
 ArrayAdapter
 CursorAdapter
 SimpleAdatper








